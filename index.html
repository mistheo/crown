<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <title>Jeu des Couronnes</title>
  <!-- Import Tailwind CSS via CDN -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- Import AlpineJS via CDN -->
  <script defer src="https://unpkg.com/alpinejs@3.x.x/dist/cdn.min.js"></script>
  <style>
    /* Overlay arc-en-ciel pour l'animation */
    .celebration-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(45deg, red, orange, yellow, green, blue, indigo, violet);
      animation: fadeOut 5s forwards;
      z-index: 500;
      pointer-events: none;
      opacity: 0.8;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    @keyframes fadeOut {
      0% { opacity: 0.8; }
      100% { opacity: 0; }
    }
    
    /* Style du message affich√© au centre de l'overlay */
    .celebration-message {
      font-size: 3rem;
      font-weight: bold;
      color: white;
      animation: messageFade 5s forwards;
    }
    @keyframes messageFade {
      0% { opacity: 1; transform: scale(1); }
      100% { opacity: 0; transform: scale(1.2); }
    }
    
    /* Conteneur de couronnes anim√©es */
    .celebration-container {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      overflow: hidden;
      z-index: 1000;
      pointer-events: none;
    }
    /* Animation de chute : les couronnes tombent depuis le haut */
    .crown {
      position: absolute;
      top: -50px;
      font-size: 2rem;
      animation: fallDown 4s ease-in-out forwards;
    }
    @keyframes fallDown {
      0% {
        transform: translateY(0) rotate(0deg);
        opacity: 1;
      }
      100% {
        transform: translateY(100vh) rotate(360deg);
        opacity: 0;
      }
    }
    
    /* Styles pour les off-canvases */
    .offcanvas {
      position: fixed;
      top: 0;
      bottom: 0;
      width: 300px;
      background: white;
      z-index: 600;
      transition: transform 0.3s ease-in-out;
      box-shadow: 0 0 10px rgba(0,0,0,0.3);
    }
    .offcanvas-right {
      right: 0;
      transform: translateX(100%);
    }
    .offcanvas-left {
      left: 0;
      transform: translateX(-100%);
    }
    .offcanvas-open { transform: translateX(0); }
    
    /* Zone de contr√¥le en bas au centre */
    .control-panel {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 700;
      display: flex;
      gap: 1rem;
    }
  </style>
</head>
<body class="bg-gray-100 p-4" x-data="game()">
  <div class="max-w-4xl mx-auto">
    <h1 class="text-2xl font-bold mb-4 text-center">Jeu des Couronnes</h1>
    
    <!-- Grille de jeu -->
    <div class="grid border-2 border-black mx-auto w-fit" :class="`grid-cols-${cols}`">
      <template x-for="(row, i) in grid.slice().reverse()" :key="i">
        <template x-for="(cell, j) in row" :key="j">
          <!-- Modification ici : classes w-16 h-16 pour agrandir les cellules -->
          <div 
            @click="handleCellClick(rows - i - 1, j)"
            class="w-16 h-16 flex items-center justify-center border text-lg font-bold cursor-pointer transition duration-100"
            :class="getCellClasses(cell)">
            <span class="relative">
              <template x-if="cell.mark === 'C'">
                <span>üëë</span>
              </template>
              <template x-if="cell.mark === 'X'">
                <span>‚ùå</span>
              </template>
            </span>
          </div>
        </template>
      </template>
    </div>

    <!-- Affichage de la seed en cours -->
    <p class="text-center mt-4 text-lg">Seed actuelle : <span class="font-bold" x-text="seed"></span></p>
  </div>

  <!-- Off-canvas pour la saisie de la seed (depuis la droite) -->
  <div 
    class="offcanvas offcanvas-right" 
    :class="{'offcanvas-open': showSeedPanel}"
    @keydown.enter.window="validateSeed()">
    <div class="p-4">
      <h2 class="text-xl font-bold mb-2">Entrer une seed</h2>
      <input 
        type="text" 
        placeholder="Tapez un mot-cl√© ou chiffre" 
        class="border p-2 w-full"
        x-model="seedInput">
      <button 
        @click="validateSeed()" 
        class="mt-2 w-full px-4 py-2 bg-green-500 text-white rounded hover:bg-green-600 transition">
        Valider
      </button>
    </div>
  </div>

  <!-- Off-canvas pour les r√®gles (depuis la gauche) -->
  <div
    class="offcanvas offcanvas-left" 
    :class="{'offcanvas-open': showRulesPanel}" >
    <div class="p-4">
      <h2 class="text-xl font-bold mb-2">R√®gles du Jeu des Couronnes</h2>
      <ul class="list-disc pl-4 mb-4">
        <li>Chaque ligne doit contenir exactement une couronne (üëë).</li>
        <li>Chaque colonne doit contenir exactement une couronne (üëë).</li>
        <li>Chaque r√©gion color√©e doit contenir exactement une couronne (üëë).</li>
        <li>Les couronnes ne peuvent pas √™tre adjacentes, m√™me en diagonale.</li>
        <li>Utilisez les marques (‚ùå) pour √©liminer des options.</li>
      </ul>
      <button 
        @click="showRulesPanel = false"
        class="mt-2 w-full px-4 py-2 bg-red-500 text-white rounded hover:bg-red-600 transition">
        Fermer
      </button>
    </div>
  </div>

  <!-- Panneau de contr√¥les en bas au centre -->
  <div class="control-panel">
    <button 
      @click="showRulesPanel = !showRulesPanel" 
      class="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 transition text-lg">
      R√®gles
    </button>
    <button 
      @click="showSeedPanel = !showSeedPanel" 
      class="px-4 py-2 bg-purple-500 text-white rounded hover:bg-purple-600 transition text-lg">
      Seed
    </button>
    <button 
      @click="rerollGame(); resetTimer(); startTimer()" 
      class="px-4 py-2 bg-green-500 text-white rounded hover:bg-green-600 transition text-lg">
      Reroll
    </button>
    <button 
      @click="clearMarks()" 
      class="px-4 py-2 bg-yellow-500 text-white rounded hover:bg-yellow-600 transition text-lg">
      Clear
    </button> 
  </div>

  <script>
    // ----------------- Random Seed Functions -----------------
    // G√©n√©rateur de hash xmur3 pour transformer la seed en entier
    function xmur3(str) {
      for (var i = 0, h = 1779033703 ^ str.length; i < str.length; i++) {
        h = Math.imul(h ^ str.charCodeAt(i), 3432918353);
      }
      return function() {
        h = Math.imul(h ^ (h >>> 16), 2246822507);
        h = Math.imul(h ^ (h >>> 13), 3266489909);
        return (h ^= h >>> 16) >>> 0;
      }
    }
    // G√©n√©rateur pseudo-al√©atoire mulberry32
    function mulberry32(a) {
      return function() {
        var t = a += 0x6D2B79F5;
        t = Math.imul(t ^ t >>> 15, t | 1);
        t ^= t + Math.imul(t ^ t >>> 7, t | 61);
        return ((t ^ t >>> 14) >>> 0) / 4294967296;
      }
    }
    // -----------------------------------------------------------

    // Modification de generateGrid pour accepter un g√©n√©rateur de nombres al√©atoires "rand"
    const generateGrid = (rand) => {
      const rows = 8, cols = 8;
      let grid = Array.from({ length: rows }, () =>
        Array.from({ length: cols }, () => ({ region: null, mark: '', isMissedPlay: false }))
      );
      const usedPositions = new Set();
      
      // Initialisation des r√©gions avec une cellule par r√©gion
      for (let region = 0; region < rows; region++) {
        let placed = false;
        while (!placed) {
          const i = Math.floor(rand() * rows);
          const j = Math.floor(rand() * cols);
          const key = `${i},${j}`;
          if (!usedPositions.has(key)) {
            grid[i][j].region = region;
            usedPositions.add(key);
            placed = true;
          }
        }
      }
      
      // Propagation des r√©gions vers les cellules voisines
      let remaining = rows * cols - usedPositions.size;
      while (remaining > 0) {
        const regionsOrder = [...Array(rows).keys()].sort(() => rand() - 0.5);
        for (let region of regionsOrder) {
          const regionCells = [];
          for (let i = 0; i < rows; i++) {
            for (let j = 0; j < cols; j++) {
              if (grid[i][j].region === region) regionCells.push([i, j]);
            }
          }
          const candidates = [];
          for (const [i, j] of regionCells) {
            [[-1,0],[1,0],[0,-1],[0,1]].forEach(([di, dj]) => {
              const ni = i + di, nj = j + dj;
              if (ni >= 0 && ni < rows && nj >= 0 && nj < cols && grid[ni][nj].region === null) {
                candidates.push([ni, nj]);
              }
            });
          }
          if (candidates.length > 0) {
            const [ci, cj] = candidates[Math.floor(rand() * candidates.length)];
            grid[ci][cj].region = region;
            remaining--;
            if (remaining <= 0) break;
          }
        }
      }
      
      // V√©rification de la taille minimale des r√©gions (>= 3 cellules)
      const regionCounts = Array(rows).fill(0);
      for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
          regionCounts[ grid[i][j].region ]++;
        }
      }
      if (regionCounts.some(count => count < 3)) {
        return generateGrid(rand);
      }
      return grid;
    };

    // Affiche l'animation de c√©l√©bration avec les couronnes
    const celebrate = () => {
      const overlay = document.createElement('div');
      overlay.className = 'celebration-overlay';
      const messageEl = document.createElement('div');
      messageEl.className = 'celebration-message';
      messageEl.innerText = "Bravo ! Vous avez gagn√© !";
      overlay.appendChild(messageEl);
      document.body.appendChild(overlay);
      setTimeout(() => overlay.remove(), 5000);

      const container = document.createElement('div');
      container.className = 'celebration-container';
      container.innerHTML = Array.from({ length: 30 }).map(() => {
        const left = Math.random() * 100;
        const delay = Math.random() * 2;
        return `<div class="crown" style="left: ${left}%; animation-delay: ${delay}s;">üëë</div>`;
      }).join('');
      document.body.appendChild(container);
      setTimeout(() => container.remove(), 8000);
    };

    // Fonction principale utilis√©e par AlpineJS
    function game() {
      // Les panneaux off-canvas
      return {
        grid: [],
        win: false,
        colors: [
          "bg-red-200", "bg-blue-300", "bg-green-200", "bg-yellow-200",
          "bg-purple-200", "bg-pink-300", "bg-indigo-200", "bg-gray-200"
        ],
        rows: 8,
        cols: 8,
        time: { min: 0, sec: 0 },
        formattedTime: "00:00",
        seed: "",       // Affiche la seed actuelle
        seedInput: "",  // Stocke l'input de l'utilisateur
        showSeedPanel: false,  // Contr√¥le l'affichage de l'off-canvas pour la seed
        showRulesPanel: false, // Contr√¥le l'affichage de l'off-canvas pour les r√®gles
        prng: null,     // G√©n√©rateur al√©atoire seedable
        timerInterval: null,

        // Initialise la partie (seed et grille)
        init() {
          // Si aucune seed n'est entr√©e, on g√©n√®re une seed al√©atoire
          if (!this.seed) {
            this.seed = Math.floor(Math.random() * 1e8).toString();
          }
          this.updatePRNG(this.seed);
          this.grid = generateGrid(this.prng);
        },

        // Met √† jour le g√©n√©rateur de nombres al√©atoires √† partir d'une seed donn√©e
        updatePRNG(newSeed) {
          this.seed = newSeed;
          const seedFn = xmur3(newSeed);
          this.prng = mulberry32(seedFn());
        },

        // Validation de la seed saisie dans l'off-canvas (et fermeture du panneau)
        validateSeed() {
          if (this.seedInput.trim() !== "") {
            this.updatePRNG(this.seedInput.trim());
            this.grid = generateGrid(this.prng);
          }
          this.seedInput = "";
          this.showSeedPanel = false;
        },

        // Met √† jour l'affichage du temps
        updateFormattedTime() {
          const m = this.time.min < 10 ? `0${this.time.min}` : this.time.min;
          const s = this.time.sec < 10 ? `0${this.time.sec}` : this.time.sec;
          this.formattedTime = `${m}:${s}`;
        },

        // D√©marre le minuteur
        startTimer() {
          if (this.timerInterval) clearInterval(this.timerInterval);
          this.timerInterval = setInterval(() => {
            this.time.sec++;
            if (this.time.sec >= 60) {
              this.time.sec = 0;
              this.time.min++;
            }
            this.updateFormattedTime();
          }, 1000);
        },

        // R√©initialise le minuteur
        resetTimer() {
          clearInterval(this.timerInterval);
          this.time = { min: 0, sec: 0 };
          this.updateFormattedTime();
        },

        // Renvoie les classes CSS d'une cellule
        getCellClasses(cell) {
          const baseClass = this.colors[cell.region];
          return cell.isMissedPlay
            ? `${baseClass} border-4 border-red-500`
            : `${baseClass} border border-black`;
        },

        // Gestion du clic sur une cellule
        handleCellClick(i, j) {
          const cell = this.grid[i][j];
          cell.isMissedPlay = false;
          cell.mark = cell.mark === '' ? 'C' : cell.mark === 'C' ? 'X' : '';
          this.evaluateGrid();
        },

        // R√©initialise toutes les marques
        clearMarks() {
          for (let i = 0; i < this.rows; i++) {
            for (let j = 0; j < this.cols; j++) {
              this.grid[i][j].mark = '';
              this.grid[i][j].isMissedPlay = false;
            }
          }
          this.win = false;
        },

        // Reroll : recr√©e une nouvelle grille avec une nouvelle seed al√©atoire
        rerollGame() {
          // G√©n√®re une nouvelle seed al√©atoire, m√™me si une seed avait √©t√© appliqu√©e manuellement
          const newSeed = Math.floor(Math.random() * 1e8).toString();
          this.updatePRNG(newSeed);
          this.grid = generateGrid(this.prng);
          this.win = false;
        },

        // √âvalue l'ensemble des r√®gles du jeu
        evaluateGrid() {
          this.win = true;
          // R√©initialisation des indicateurs d'erreur
          for (let i = 0; i < this.rows; i++) {
            for (let j = 0; j < this.cols; j++) {
              this.grid[i][j].isMissedPlay = false;
            }
          }
          let hasError = false;

          // V√©rification des lignes
          for (let i = 0; i < this.rows; i++) {
            const crowns = [];
            for (let j = 0; j < this.cols; j++) {
              if (this.grid[i][j].mark === 'C') {
                crowns.push([i, j]);
              }
            }
            if (crowns.length !== 1) {
              hasError = true;
              crowns.forEach(([i, j]) => this.grid[i][j].isMissedPlay = true);
            }
          }

          // V√©rification des colonnes
          for (let j = 0; j < this.cols; j++) {
            const crowns = [];
            for (let i = 0; i < this.rows; i++) {
              if (this.grid[i][j].mark === 'C') {
                crowns.push([i, j]);
              }
            }
            if (crowns.length !== 1) {
              hasError = true;
              crowns.forEach(([i, j]) => this.grid[i][j].isMissedPlay = true);
            }
          }

          // V√©rification par r√©gion
          const regionCrowns = Array.from({ length: this.rows }, () => []);
          for (let i = 0; i < this.rows; i++) {
            for (let j = 0; j < this.cols; j++) {
              if (this.grid[i][j].mark === 'C') {
                regionCrowns[this.grid[i][j].region].push([i, j]);
              }
            }
          }
          for (let r = 0; r < this.rows; r++) {
            if (regionCrowns[r].length !== 1) {
              hasError = true;
              regionCrowns[r].forEach(([i, j]) => this.grid[i][j].isMissedPlay = true);
            }
          }

          // V√©rification des cellules adjacentes (8 directions)
          const adjacentDirs = [[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]];
          for (let i = 0; i < this.rows; i++) {
            for (let j = 0; j < this.cols; j++) {
              if (this.grid[i][j].mark === 'C') {
                for (const [di, dj] of adjacentDirs) {
                  const ni = i + di, nj = j + dj;
                  if (ni >= 0 && ni < this.rows && nj >= 0 && nj < this.cols) {
                    if (this.grid[ni][nj].mark === 'C') {
                      this.grid[i][j].isMissedPlay = true;
                      this.grid[ni][nj].isMissedPlay = true;
                      hasError = true;
                    }
                  }
                }
              }
            }
          }
          this.win = !hasError;
          if (this.win) {
            celebrate();
          }
        }
      }
    }
    // Initialisation
    window.addEventListener('alpine:init', () => {
      Alpine.data('game', game);
    });
  </script>
</body>
</html>
